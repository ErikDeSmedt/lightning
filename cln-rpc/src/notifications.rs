#![allow(non_camel_case_types)]
// This file is autogenerated by `msggen`
// Do not edit it manually, your changes will be overwritten



use crate::primitives::*;
use serde::{Serialize, Deserialize};
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum Notification {
    #[serde(rename = "block_added")]
    BlockAdded(BlockAddedNotification),
    #[serde(rename = "channel_open_failed")]
    ChannelOpenFailed(ChannelOpenFailedNotification),
    #[serde(rename = "channel_opened")]
    ChannelOpened(ChannelOpenedNotification),
    #[serde(rename = "connect")]
    Connect(ConnectNotification),
    #[serde(rename = "custommsg")]
    CustomMsg(CustomMsgNotification),
}


#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Block_addedBlock_added {
    pub hash: Sha256,
    pub height: u32,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlockAddedNotification {
    pub block_added: Block_addedBlock_added,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Channel_open_failedChannel_open_failed {
    pub channel_id: Sha256,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ChannelOpenFailedNotification {
    pub channel_open_failed: Channel_open_failedChannel_open_failed,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Channel_openedChannel_opened {
    pub channel_ready: bool,
    pub funding_msat: Amount,
    pub funding_txid: String,
    pub id: PublicKey,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ChannelOpenedNotification {
    pub channel_opened: Channel_openedChannel_opened,
}

/// ['Direction of the connection']
#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub enum ConnectConnectDirection {
}

impl TryFrom<i32> for ConnectConnectDirection {
    type Error = anyhow::Error;
    fn try_from(c: i32) -> Result<ConnectConnectDirection, anyhow::Error> {
        match c {
    0 => Ok(ConnectConnectDirection::IN),
    1 => Ok(ConnectConnectDirection::OUT),
            o => Err(anyhow::anyhow!("Unknown variant {} for enum ConnectConnectDirection", o)),
        }
    }
}

impl ToString for ConnectConnectDirection {
    fn to_string(&self) -> String {
        match self {
            ConnectConnectDirection::IN => "IN",
            ConnectConnectDirection::OUT => "OUT",
        }.to_string()
    }
}

/// ['Type of connection (*torv2*/*torv3* only if **direction** is *out*)']
#[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub enum ConnectConnectAddressType {
}

impl TryFrom<i32> for ConnectConnectAddressType {
    type Error = anyhow::Error;
    fn try_from(c: i32) -> Result<ConnectConnectAddressType, anyhow::Error> {
        match c {
    0 => Ok(ConnectConnectAddressType::LOCAL_SOCKET),
    1 => Ok(ConnectConnectAddressType::IPV4),
    2 => Ok(ConnectConnectAddressType::IPV6),
    3 => Ok(ConnectConnectAddressType::TORV2),
    4 => Ok(ConnectConnectAddressType::TORV3),
            o => Err(anyhow::anyhow!("Unknown variant {} for enum ConnectConnectAddressType", o)),
        }
    }
}

impl ToString for ConnectConnectAddressType {
    fn to_string(&self) -> String {
        match self {
            ConnectConnectAddressType::LOCAL_SOCKET => "LOCAL_SOCKET",
            ConnectConnectAddressType::IPV4 => "IPV4",
            ConnectConnectAddressType::IPV6 => "IPV6",
            ConnectConnectAddressType::TORV2 => "TORV2",
            ConnectConnectAddressType::TORV3 => "TORV3",
        }.to_string()
    }
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ConnectConnectAddress {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<u16>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub socket: Option<String>,
    // Path `connect.connect.address.type`
    #[serde(rename = "type")]
    pub item_type: ConnectConnectAddressType,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ConnectConnect {
    // Path `connect.connect.direction`
    pub direction: ConnectConnectDirection,
    pub address: ConnectConnectAddress,
    pub id: PublicKey,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ConnectNotification {
    pub connect: ConnectConnect,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CustommsgCustommsg {
    pub payload: String,
    pub peer_id: PublicKey,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CustomMsgNotification {
    pub custommsg: CustommsgCustommsg,
}

pub mod requests{
use serde::{Serialize, Deserialize};

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StreamBlockAddedRequest {
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StreamChannelOpenFailedRequest {
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StreamChannelOpenedRequest {
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StreamConnectRequest {
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct StreamCustomMsgRequest {
    }

}
